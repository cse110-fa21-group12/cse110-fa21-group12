const crypto = require("crypto"),
  jwt = require("jsonwebtoken"),
  config = require("../config");
class TokenExpiredError extends Error {
  constructor(a = "Token expired error.") {
    super(a);
  }
}
class TokenSignError extends Error {
  constructor(a = "Token sign error.") {
    super(a);
  }
}
async function hashPassword(a) {
  return new Promise((b, c) => {
    const d = crypto.randomBytes(8).toString("hex");
    crypto.scrypt(a, d, 64, (a, e) => {
      a && c(a), b(d + ":" + e.toString("hex"));
    });
  });
}
async function verifyPassword(a, b) {
  return new Promise((c, d) => {
    const [e, f] = b.split(":");
    crypto.scrypt(a, e, 64, (a, b) => {
      a && d(a), c(f == b.toString("hex"));
    });
  });
}
function verifyToken(a, b, c) {
  const d = a.cookies.token || a.headers["x-access-token"];
  return d
    ? void jwt.verify(d, config.jwtKeyPublic, (b, d) => {
        if (b) {
          if ("TokenExpiredError" == b.name)
            throw new TokenExpiredError(JSON.stringify(b));
          return c(b);
        }
        (a.user = d), c();
      })
    : b.status(403).end("A token is required for authentication");
}
async function generateToken(
  a,
  { expiresIn: b } = { expiresIn: "30 minutes" }
) {
  return new Promise((c, d) => {
    jwt.sign(
      a,
      config.jwtKeyPrivate,
      { algorithm: "RS256", expiresIn: b },
      (a, b) => {
        a && d(TokenSignError(a)), c(b);
      }
    );
  });
}
module.exports = { generateToken, verifyToken, hashPassword, verifyPassword };
